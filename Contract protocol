import { Protocol } from 'trac-peer';
import { bufferToBigInt, bigIntToDecimalString } from 'trac-msb/src/utils/amountSerialization.js';
import b4a from 'b4a';
import PeerWallet from 'trac-wallet';
import fs from 'fs';

const stableStringify = (value) => {
  if (value === null || value === undefined) return 'null';
  if (typeof value !== 'object') return JSON.stringify(value);
  if (Array.isArray(value)) return `[${value.map(stableStringify).join(',')}]`;
  const keys = Object.keys(value).sort();
  return `{${keys.map((key) => `${JSON.stringify(key)}:${stableStringify(value[key])}`).join(',')}}`;
};

const normalizeInvitePayload = (payload) => ({
  channel: String(payload?.channel ?? ''),
  inviteePubKey: String(payload?.inviteePubKey ?? '').trim().toLowerCase(),
  inviterPubKey: String(payload?.inviterPubKey ?? '').trim().toLowerCase(),
  inviterAddress: payload?.inviterAddress ?? null,
  issuedAt: Number(payload?.issuedAt),
  expiresAt: Number(payload?.expiresAt),
  nonce: String(payload?.nonce ?? ''),
  version: Number.isFinite(payload?.version) ? Number(payload.version) : 1,
});

const normalizeWelcomePayload = (payload) => ({
  channel: String(payload?.channel ?? ''),
  ownerPubKey: String(payload?.ownerPubKey ?? '').trim().toLowerCase(),
  text: String(payload?.text ?? ''),
  issuedAt: Number(payload?.issuedAt),
  version: Number.isFinite(payload?.version) ? Number(payload.version) : 1,
});

const parseInviteArg = (raw) => {
  if (!raw) return null;
  let text = String(raw || '').trim();
  if (!text) return null;
  if (text.startsWith('@')) {
    try { text = fs.readFileSync(text.slice(1), 'utf8').trim(); } catch (_e) { return null; }
  }
  if (text.startsWith('b64:')) text = text.slice(4);
  if (text.startsWith('{')) {
    try { return JSON.parse(text); } catch (_e) {}
  }
  try {
    const decoded = b4a.toString(b4a.from(text, 'base64'));
    return JSON.parse(decoded);
  } catch (_e) {}
  return null;
};

const parseWelcomeArg = (raw) => {
  if (!raw) return null;
  let text = String(raw || '').trim();
  if (!text) return null;
  if (text.startsWith('@')) {
    try { text = fs.readFileSync(text.slice(1), 'utf8').trim(); } catch (_e) { return null; }
  }
  if (text.startsWith('b64:')) text = text.slice(4);
  if (text.startsWith('{')) {
    try { return JSON.parse(text); } catch (_e) {}
  }
  try {
    const decoded = b4a.toString(b4a.from(text, 'base64'));
    return JSON.parse(decoded);
  } catch (_e) {}
  return null;
};

class JobBoardProtocol extends Protocol {
  /**
   * IntercomJobBoard Protocol
   * Forked from Trac Intercom reference implementation.
   * Maps terminal commands to JobBoardContract functions.
   */
  constructor(peer, base, options = {}) {
    super(peer, base, options);
  }

  async extendApi() {
    this.api.getBoardStats = async function () {
      return 'Use /tx --command "read_stats" to view job board stats.';
    };
  }

  /**
   * Maps /tx --command "..." to contract functions.
   *
   * Job board commands:
   *   /tx --command '{"op":"post_job","title":"...","description":"...","contact":"...","category":"remote","budget":"500 TNK"}'
   *   /tx --command '{"op":"apply_job","job_id":0,"skills":"...","contact":"..."}'
   *   /tx --command '{"op":"close_job","job_id":0}'
   *   /tx --command '{"op":"read_job","job_id":0}'
   *   /tx --command '{"op":"read_job_apps","job_id":0}'
   *   /tx --command "read_stats"
   *   /tx --command "read_timer"
   *   /tx --command "read_chat_last"
   */
  mapTxCommand(command) {
    let obj = { type: '', value: null };

    // simple string commands
    if (command === 'read_stats') {
      obj.type = 'readStats';
      obj.value = null;
      return obj;
    }
    if (command === 'read_timer') {
      obj.type = 'readTimer';
      obj.value = null;
      return obj;
    }
    if (command === 'read_chat_last') {
      obj.type = 'readChatLast';
      obj.value = null;
      return obj;
    }

    // JSON commands
    const json = this.safeJsonParse(command);
    if (json?.op === undefined) return null;

    if (json.op === 'post_job') {
      obj.type = 'postJob';
      obj.value = json;
      return obj;
    }
    if (json.op === 'apply_job') {
      obj.type = 'applyJob';
      obj.value = json;
      return obj;
    }
    if (json.op === 'close_job') {
      obj.type = 'closeJob';
      obj.value = json;
      return obj;
    }
    if (json.op === 'read_job') {
      obj.type = 'readJob';
      obj.value = json;
      return obj;
    }
    if (json.op === 'read_job_apps') {
      obj.type = 'readJobApps';
      obj.value = json;
      return obj;
    }
    if (json.op === 'read_stats') {
      obj.type = 'readStats';
      obj.value = null;
      return obj;
    }
    if (json.op === 'filter_by_skill') {
      obj.type = 'filterBySkill';
      obj.value = json;
      return obj;
    }
    if (json.op === 'read_skill_jobs') {
      obj.type = 'readSkillJobs';
      obj.value = json;
      return obj;
    }

    return null;
  }

  async printOptions() {
    console.log(' ');
    console.log('=== INTERCOM JOB BOARD ===');
    console.log('');
    console.log('--- Contract Commands (on-chain, costs 0.03 TNK each) ---');
    console.log('/tx --command \'{"op":"post_job","title":"Senior Dev","description":"Build P2P apps","contact":"trac1...","category":"remote","budget":"500 TNK"}\'');
    console.log('/tx --command \'{"op":"post_job","title":"Barista","description":"Coffee shop Lagos","contact":"080...","category":"local"}\'');
    console.log('/tx --command \'{"op":"apply_job","job_id":0,"skills":"JavaScript, Node.js, 3yr exp","contact":"trac1..."}\'');
    console.log('/tx --command \'{"op":"close_job","job_id":0}\'');
    console.log('/tx --command \'{"op":"read_job","job_id":0}\'');
    console.log('/tx --command \'{"op":"read_job_apps","job_id":0}\'');
    console.log('/tx --command "read_stats"');
    console.log('/tx --command "read_timer"');
    console.log('');
    console.log('--- Skill Tag Commands (unique feature) ---');
    console.log('/tx --command \'{"op":"post_job","title":"Dev","description":"Build apps","contact":"trac1...","category":"remote","skills":"javascript,nodejs,p2p","budget":"200 TNK"}\'');
    console.log('/tx --command \'{"op":"filter_by_skill","skill":"javascript"}\' | find all open jobs requiring javascript');
    console.log('/tx --command \'{"op":"filter_by_skill","skill":"nodejs"}\' | find all open jobs requiring nodejs');
    console.log('/tx --command \'{"op":"read_skill_jobs","skill":"p2p"}\' | count jobs for a skill');
    console.log('/get --key "skills/javascript/count" | raw skill index count');
    console.log('');
    console.log('--- Simulate before spending TNK ---');
    console.log('/tx --command \'{"op":"post_job",...}\' --sim 1');
    console.log('');
    console.log('--- Sidechannel Commands (free, ephemeral) ---');
    console.log('/sc_send --channel jobs-general --message "HIRE: Senior Dev | Remote | 500 TNK | trac1..."');
    console.log('/sc_send --channel jobs-remote  --message "HIRE: UI Designer | Remote | $80k | trac1..."');
    console.log('/sc_send --channel jobs-local   --message "HIRE: Barista | Lagos | Part time | 080..."');
    console.log('/sc_send --channel jobs-general --message "APPLY: JS/Python dev | 3yr exp | trac1..."');
    console.log('/sc_join --channel jobs-remote');
    console.log('/sc_stats');
    console.log('');
    console.log('--- System ---');
    console.log('/get --key "jobs/count"');
    console.log('/get --key "jobs/0"');
    console.log('/stats');
    console.log('/msb');
    console.log('/help');
    console.log('/exit');
  }

  async customCommand(input) {
    await super.tokenizeInput(input);

    if (this.input.startsWith('/get')) {
      const m = input.match(/(?:^|\s)--key(?:=|\s+)(\"[^\"]+\"|'[^']+'|\S+)/);
      const raw = m ? m[1].trim() : null;
      if (!raw) {
        console.log('Usage: /get --key "<key>" [--confirmed true|false]');
        return;
      }
      const key = raw.replace(/^\"(.*)\"$/, '$1').replace(/^'(.*)'$/, '$1');
      const confirmedMatch = input.match(/(?:^|\s)--confirmed(?:=|\s+)(\S+)/);
      const unconfirmedMatch = input.match(/(?:^|\s)--unconfirmed(?:=|\s+)?(\S+)?/);
      const confirmed = unconfirmedMatch ? false : confirmedMatch ? confirmedMatch[1] === 'true' || confirmedMatch[1] === '1' : true;
      const v = confirmed ? await this.getSigned(key) : await this.get(key);
      console.log(v);
      return;
    }

    if (this.input.startsWith('/msb')) {
      const txv = await this.peer.msbClient.getTxvHex();
      const peerMsbAddress = this.peer.msbClient.pubKeyHexToAddress(this.peer.wallet.publicKey);
      const entry = await this.peer.msbClient.getNodeEntryUnsigned(peerMsbAddress);
      const balance = entry?.balance ? bigIntToDecimalString(bufferToBigInt(entry.balance)) : 0;
      const feeBuf = this.peer.msbClient.getFee();
      const fee = feeBuf ? bigIntToDecimalString(bufferToBigInt(feeBuf)) : 0;
      const validators = this.peer.msbClient.getConnectedValidatorsCount();
      console.log({
        networkId: this.peer.msbClient.networkId,
        msbBootstrap: this.peer.msbClient.bootstrapHex,
        txv,
        msbSignedLength: this.peer.msbClient.getSignedLength(),
        msbUnsignedLength: this.peer.msbClient.getUnsignedLength(),
        connectedValidators: validators,
        peerMsbAddress,
        peerMsbBalance: balance,
        msbFee: fee,
      });
      return;
    }

    if (this.input.startsWith('/sc_join')) {
      const args = this.parseArgs(input);
      const name = args.channel || args.ch || args.name;
      const inviteArg = args.invite || args.invite_b64 || args.invitebase64;
      const welcomeArg = args.welcome || args.welcome_b64 || args.welcomebase64;
      if (!name) {
        console.log('Usage: /sc_join --channel "<name>" [--invite <json|b64|@file>] [--welcome <json|b64|@file>]');
        return;
      }
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      let invite = null;
      if (inviteArg) {
        invite = parseInviteArg(inviteArg);
        if (!invite) { console.log('Invalid invite.'); return; }
      }
      let welcome = null;
      if (welcomeArg) {
        welcome = parseWelcomeArg(welcomeArg);
        if (!welcome) { console.log('Invalid welcome.'); return; }
      }
      if (invite || welcome) this.peer.sidechannel.acceptInvite(String(name), invite, welcome);
      const ok = await this.peer.sidechannel.addChannel(String(name));
      if (!ok) { console.log('Join denied (invite required or invalid).'); return; }
      console.log('Joined sidechannel:', name);
      return;
    }

    if (this.input.startsWith('/sc_send')) {
      const args = this.parseArgs(input);
      const name = args.channel || args.ch || args.name;
      const message = args.message || args.msg;
      const inviteArg = args.invite || args.invite_b64 || args.invitebase64;
      const welcomeArg = args.welcome || args.welcome_b64 || args.welcomebase64;
      if (!name || message === undefined) {
        console.log('Usage: /sc_send --channel "<name>" --message "<text>"');
        return;
      }
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      let invite = null;
      if (inviteArg) {
        invite = parseInviteArg(inviteArg);
        if (!invite) { console.log('Invalid invite.'); return; }
      }
      let welcome = null;
      if (welcomeArg) {
        welcome = parseWelcomeArg(welcomeArg);
        if (!welcome) { console.log('Invalid welcome.'); return; }
      }
      if (invite || welcome) this.peer.sidechannel.acceptInvite(String(name), invite, welcome);
      const ok = await this.peer.sidechannel.addChannel(String(name));
      if (!ok) { console.log('Send denied (invite required or invalid).'); return; }
      const sent = this.peer.sidechannel.broadcast(String(name), message, invite ? { invite } : undefined);
      if (!sent) console.log('Send denied (owner-only or invite required).');
      return;
    }

    if (this.input.startsWith('/sc_open')) {
      const args = this.parseArgs(input);
      const name = args.channel || args.ch || args.name;
      const via = args.via || args.channel_via;
      const inviteArg = args.invite || args.invite_b64 || args.invitebase64;
      const welcomeArg = args.welcome || args.welcome_b64 || args.welcomebase64;
      if (!name) {
        console.log('Usage: /sc_open --channel "<name>" [--via "<channel>"]');
        return;
      }
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      let invite = null;
      if (inviteArg) {
        invite = parseInviteArg(inviteArg);
        if (!invite) { console.log('Invalid invite.'); return; }
      }
      let welcome = null;
      if (welcomeArg) {
        welcome = parseWelcomeArg(welcomeArg);
        if (!welcome) { console.log('Invalid welcome.'); return; }
      } else if (typeof this.peer.sidechannel.getWelcome === 'function') {
        welcome = this.peer.sidechannel.getWelcome(String(name));
      }
      const viaChannel = via || this.peer.sidechannel.entryChannel || null;
      if (!viaChannel) { console.log('No entry channel. Pass --via "<channel>".'); return; }
      this.peer.sidechannel.requestOpen(String(name), String(viaChannel), invite, welcome);
      console.log('Requested channel:', name);
      return;
    }

    if (this.input.startsWith('/sc_invite')) {
      const args = this.parseArgs(input);
      const channel = args.channel || args.ch || args.name;
      const invitee = args.pubkey || args.invitee || args.peer || args.key;
      const ttlRaw = args.ttl || args.ttl_sec || args.ttl_s;
      const welcomeArg = args.welcome || args.welcome_b64 || args.welcomebase64;
      if (!channel || !invitee) {
        console.log('Usage: /sc_invite --channel "<name>" --pubkey "<peer-pubkey-hex>" [--ttl <sec>]');
        return;
      }
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      if (this.peer?.wallet?.ready) { try { await this.peer.wallet.ready; } catch (_e) {} }
      const walletPub = this.peer?.wallet?.publicKey;
      const inviterPubKey = walletPub
        ? typeof walletPub === 'string' ? walletPub.trim().toLowerCase() : b4a.toString(walletPub, 'hex')
        : null;
      if (!inviterPubKey) { console.log('Wallet not ready.'); return; }
      let inviterAddress = null;
      try { if (this.peer?.msbClient) inviterAddress = this.peer.msbClient.pubKeyHexToAddress(inviterPubKey); } catch (_e) {}
      const issuedAt = Date.now();
      let ttlMs = null;
      if (ttlRaw !== undefined) {
        const ttlSec = Number.parseInt(String(ttlRaw), 10);
        ttlMs = Number.isFinite(ttlSec) ? Math.max(ttlSec, 0) * 1000 : null;
      } else if (Number.isFinite(this.peer.sidechannel.inviteTtlMs) && this.peer.sidechannel.inviteTtlMs > 0) {
        ttlMs = this.peer.sidechannel.inviteTtlMs;
      } else {
        ttlMs = 0;
      }
      if (!ttlMs || ttlMs <= 0) { console.log('Invite TTL required. Pass --ttl <sec>.'); return; }
      const expiresAt = issuedAt + ttlMs;
      const payload = normalizeInvitePayload({
        channel: String(channel), inviteePubKey: String(invitee).trim().toLowerCase(),
        inviterPubKey, inviterAddress, issuedAt, expiresAt,
        nonce: Math.random().toString(36).slice(2, 10), version: 1,
      });
      const message = stableStringify(payload);
      const msgBuf = b4a.from(message);
      let sig = this.peer.wallet.sign(msgBuf);
      let sigHex = typeof sig === 'string' ? sig : sig?.length > 0 ? b4a.toString(sig, 'hex') : '';
      if (!sigHex) {
        const walletSecret = this.peer?.wallet?.secretKey;
        const secretBuf = walletSecret
          ? b4a.isBuffer(walletSecret) ? walletSecret
            : typeof walletSecret === 'string' ? b4a.from(walletSecret, 'hex') : b4a.from(walletSecret)
          : null;
        if (secretBuf) {
          const sigBuf = PeerWallet.sign(msgBuf, secretBuf);
          if (sigBuf?.length > 0) sigHex = b4a.toString(sigBuf, 'hex');
        }
      }
      let welcome = null;
      if (welcomeArg) {
        welcome = parseWelcomeArg(welcomeArg);
        if (!welcome) { console.log('Invalid welcome.'); return; }
      } else if (typeof this.peer.sidechannel.getWelcome === 'function') {
        welcome = this.peer.sidechannel.getWelcome(String(channel));
      }
      const invite = { payload, sig: sigHex, welcome: welcome || undefined };
      const inviteJson = JSON.stringify(invite);
      const inviteB64 = b4a.toString(b4a.from(inviteJson), 'base64');
      if (!sigHex) { console.log('Failed to sign invite; wallet secret key unavailable.'); return; }
      console.log(inviteJson);
      console.log('invite_b64:', inviteB64);
      return;
    }

    if (this.input.startsWith('/sc_welcome')) {
      const args = this.parseArgs(input);
      const channel = args.channel || args.ch || args.name;
      const text = args.text || args.message || args.msg;
      if (!channel || text === undefined) {
        console.log('Usage: /sc_welcome --channel "<name>" --text "<message>"');
        return;
      }
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      if (this.peer?.wallet?.ready) { try { await this.peer.wallet.ready; } catch (_e) {} }
      const walletPub = this.peer?.wallet?.publicKey;
      const ownerPubKey = walletPub
        ? typeof walletPub === 'string' ? walletPub.trim().toLowerCase() : b4a.toString(walletPub, 'hex')
        : null;
      if (!ownerPubKey) { console.log('Wallet not ready.'); return; }
      const payload = normalizeWelcomePayload({
        channel: String(channel), ownerPubKey, text: String(text), issuedAt: Date.now(), version: 1,
      });
      const message = stableStringify(payload);
      const msgBuf = b4a.from(message);
      let sig = this.peer.wallet.sign(msgBuf);
      let sigHex = typeof sig === 'string' ? sig : sig?.length > 0 ? b4a.toString(sig, 'hex') : '';
      if (!sigHex) {
        const walletSecret = this.peer?.wallet?.secretKey;
        const secretBuf = walletSecret
          ? b4a.isBuffer(walletSecret) ? walletSecret
            : typeof walletSecret === 'string' ? b4a.from(walletSecret, 'hex') : b4a.from(walletSecret)
          : null;
        if (secretBuf) {
          const sigBuf = PeerWallet.sign(msgBuf, secretBuf);
          if (sigBuf?.length > 0) sigHex = b4a.toString(sigBuf, 'hex');
        }
      }
      if (!sigHex) { console.log('Failed to sign welcome.'); return; }
      const welcome = { payload, sig: sigHex };
      try { this.peer.sidechannel.acceptInvite(String(channel), null, welcome); } catch (_e) {}
      const welcomeJson = JSON.stringify(welcome);
      const welcomeB64 = b4a.toString(b4a.from(welcomeJson), 'base64');
      console.log(welcomeJson);
      console.log('welcome_b64:', welcomeB64);
      return;
    }

    if (this.input.startsWith('/sc_stats')) {
      if (!this.peer.sidechannel) { console.log('Sidechannel not initialized.'); return; }
      const channels = Array.from(this.peer.sidechannel.channels.keys());
      const connectionCount = this.peer.sidechannel.connections.size;
      console.log({ channels, connectionCount });
      return;
    }
  }
}

export default JobBoardProtocol;
